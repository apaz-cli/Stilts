%include <assert.h>
%extra void* extra;
%extra void* type;

file      <- sh:SHEBANG? topdecl (SEMI topdecl)*

/****************/
/* DECLARATIONS */
/****************/

topdecl    <- structdecl / uniondecl / traitdecl / fndecl / impldecl / nsdecl


structdecl <- s:STRUCT id:STRUCTIDENT tmpl:tmpldecl?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:typemember {add(members, m)})*
              RCBRACK
              n:{n = node(STRUCT, s, id, members);
              rule = tmpl != SUCC ? rule=node(TMPLSTRUCT, tmpl, n) : n}

uniondecl  <- u:UNION id:STRUCTIDENT tmpl:tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:typemember {add(members, m)})*
              RCBRACK
              n:{n = node(STRUCT, u, id, members);
              rule = tmpl != SUCC ? rule=node(TMPLSTRUCT, tmpl, n) : n}
              

traitdecl  <- t:TRAIT id:STRUCTIDENT tmpl:tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:fnmember {add(members, m)})*
              RCBRACK
              n:{n = node(STRUCT, t, id, members);
              rule = tmpl != SUCC ? rule=node(TMPLSTRUCT, tmpl, n) : n}

fndecl     <- FN fnproto tmplexpand? expr

impldecl   <- IMPL tt:STRUCTIDENT tmplexpand?
              FOR ft:type
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:fnmember {add(members, m)})*
              RCBRACK

nsdecl     <- NAMESPACE t:STRUCTIDENT {rule=node(NAMESPACE, t)}

typemember <- t:type v:VARIDENT SEMI {rule=node(TYPEMEMBER, t, v)}

fnmember   <- r:(fndecl / fnproto) SEMI {rule=r}


/*********/
/* TYPES */
/*********/

%node TYPE
%node TMPLTYPE
%node TRAITTYPE
%node STRUCTTYPE
type<size_t depth = 0>
           <- v:VOIDTYPE   !STAR              {rule=node(TYPE, v)} // Void means nothing.
            / v:VOIDTYPE   (STAR {depth++})+  {rule=node(TYPE, v)} // Void* means anything.
            / s:SELFTYPE   (STAR {depth++})*  {rule=node(TYPE, s)} // Self refers to the type of the first arg, or the current type.
            / t:traittype  (STAR {depth++})*  {rule=node(TYPE, t)} // Trait object (+1 pointer, trait)
            / s:structtype (STAR {depth++})*  {rule=node(TYPE, t)} // Type identifier
            / f:fntype     (STAR {depth++})*  {rule=node(TYPE, f)} // Fn<From -> To> is To(*fptr)(From).
            
            
traittype  <- i:TRAITIDENT t:tmplexpand?
              {ret = t ? node(TMPLTYPE, t, i) : node(TYPE, i)}

structtype <- s:STRUCTIDENT t:tmplexpand?
              {ret = t ? node(TMPLTYPE, t, s) : node(TYPE, s)}

%node ARGTYPES
fntype     <- fn:FNTYPE
              LT
              argtypes:{ret=list(ARGTYPES)}
              (      t:type {add(argtypes, t)})?
              (COMMA t:type {add(argtypes, t)})*
              ARROW
              rettype:type
              GT
              {rule=node(FNTYPE, argtypes, rettype)}
              / FN tmp:{rule=node(FNTYPE, (tmp=list(ARGTYPES), add(tmp, leaf(VOIDTYPE)), tmp), leaf(VOIDTYPE))}


/***********************/
/* FUNCTIONS AND TYPES */
/***********************/

tmpldecl   <- TEMPLATE

tmplspec   <- 

tmplexpand <- LT tmplmember? (COMMA tmplmember)* GT

tmplmember <- type

fnproto    <- type OPEN fnarg? (COMMA fnarg)* CLOSE

fnarg      <- type (VARIDENT tmplexpand?)?

fnbody     <- expr


/****************************/
/* CONTROL FLOW EXPRESSIONS */
/****************************/

expr       <- cfexpr / binop

cfexpr     <- forexpr / whileexpr / ternexpr

forexpr    <- FOR OPEN? expr (COLON / IN)   expr CLOSE? expr
            / FOR OPEN? expr SEMI expr SEMI expr CLOSE? expr

whileexpr  <- WHILE OPEN? expr CLOSE? expr

%node TERN
%node IFEXP
ternexpr   <- n:next (q:QUEST qe:expr (c:COLON ce:expr)?)?
              {rule = (qe==SUCC) ? n
                    : (ce==SUCC) ? node(IFEXP, q, n, qe)
                    :              node(TERN, q, c, n, qe, ce)}

thenexpr   <- n:next (THEN expr)?

alsoexpr   <- n:next (ALSO expr)?

/********************/
/* BINARY OPERATORS */
/********************/

binop      <- next

eqexpr     <- n:next {rule=n}
             (op:(EQ / PLEQ / MINEQ / MULEQ / DIVEQ / MODEQ / ANDEQ / OREQ / XOREQ / BNEQ / BSREQ / BSLEQ)
              t:next
              // Requires information about what the next expression is
              { 
                if (op->kind == kind(EQ))         rule=node(EQ, op, rule, t);
                else if (op->kind == kind(PLEQ))  rule=node(EQ, op, rule, node(PLUS,  op, rule, t));
                else if (op->kind == kind(MINEQ)) rule=node(EQ, op, rule, node(MINUS, op, rule, t));
                else if (op->kind == kind(MULEQ)) rule=node(EQ, op, rule, node(MUL,   op, rule, t));
                else if (op->kind == kind(DIVEQ)) rule=node(EQ, op, rule, node(DIV,   op, rule, t));
                else if (op->kind == kind(MODEQ)) rule=node(EQ, op, rule, node(MOD,   op, rule, t));
                else if (op->kind == kind(ANDEQ)) rule=node(EQ, op, rule, node(AND,   op, rule, t));
                else if (op->kind == kind(OREQ))  rule=node(EQ, op, rule, node(OR,    op, rule, t));
                else if (op->kind == kind(XOREQ)) rule=node(EQ, op, rule, node(BNEQ,  op, rule, t));
                else if (op->kind == kind(BSREQ)) rule=node(EQ, op, rule, node(BSR,   op, rule, t));
                else if (op->kind == kind(BSLEQ)) rule=node(EQ, op, rule, node(BSL,   op, rule, t));
                else
                  #if defined(__DAI_UNREACHABLE)
                    __DAI_UNREACHABLE()
                  #else
                    assert(!"Unexpected node type.")
                  #endif
              })*

logorexpr  <- n:next {rule=n} (op:LOGOR  n:next {rule=node(LOGOR,  op, rule, n)})*
logandexpr <- n:next {rule=n} (op:LOGAND n:next {rule=node(LOGAND, op, rule, n)})*
binorexpr  <- n:next {rule=n} (op:OR     n:next {rule=node(OR,     op, rule, n)})*
binxorexpr <- n:next {rule=n} (op:XOR    n:next {rule=node(XOR,    op, rule, n)})*
binandexpr <- n:next {rule=n} (op:AND    n:next {rule=node(AND,    op, rule, n)})*

deneqexpr  <- n:next {rule=n}
             (op:DEQ n:next {rule=node(DEQ, op, rule, n)}
             /op:NEQ n:next {rule=node(NEQ, op, rule, n)})*

cmpexpr    <- n:next {rule=n}
             (op:LT  n:next {rule=node(LT,  op, rule, n)}
             /op:GT  n:next {rule=node(GT,  op, rule, n)}
             /op:LEQ n:next {rule=node(LEQ, op, rule, n)}
             /op:GEQ n:next {rule=node(GEQ, op, rule, n)})*

shfexpr    <- n:next {rule=n} // Tokenized as << and >>.
             (l:LT lt:LT n:next {rule=node(BSL, l, lt, rule, n)}
             /g:GT gt:GT n:next {rule=node(BSR, g, gt, rule, n)})*

powexpr    <- n:next {rule=n} (op:POW {rule=node(POW, op, rule, n)})*

multexpr   <- n:next {rule=n}
             (op:STAR n:next {rule=node(STAR, op, rule, n)}
             /op:DIV  n:next {rule=node(DIV,  op, rule, n)}
             /op:MOD  n:next {rule=node(MOD,  op, rule, n)})*

sumexpr    <- n:next {rule=n}
             (op:PLUS  n:next {rule=node(PLUS, op, rule, n)}
             /op:MINUS n:next {rule=node(MINUS, op, rule, n)})*

callexpr   <- VARIDENT t:tmplexpand? OPEN CLOSE
            / n:next {rule=n}

castexpr   <- n:next o:OPEN t:type CLOSE {rule=node(CAST, o, t, n)}
            / re:refexpr {rule = re}

refexpr    <- n:next r:REF?    {rule=(r != SUCC) ? node(REF, r, n) : n}

derefexpr  <- n:next d:DEREF?  {rule=(d != SUCC) ? node(REF, d, n) : n}

postretexpr <- n:next g:GRAVE? {rule=(g != SUCC) ? node(RET, g, n) : n}

/*********************************/
/* ATOMS AND SPECIAL EXPRESSIONS */
/*********************************/

atomexpr   <- blockexpr
            / lambdaexpr
            / listcomp
            / listlit
            / parenexpr
            / ctypeexpr
            / cfuncexpr
            / preretexpr
            / VARIDENT
            / NUMLIT
            / STRLIT

blockexpr  <- LCBRACK
              {rule=list(BLK)}
              (e:expr {add(rule, e)})*
              RCBRACK

lambdaexpr <- OPEN CLOSE

listcomp   <- LSBRACK
              (cnt:VARIDENT COMMA)? expr   // Optional count
              FOR item:VARIDENT
              IN expr
              (WHERE expr)?
              RSBRACK

listlit    <- LSBRACK expr? (COMMA expr)* COMMA? RSBRACK

parenexpr  <- OPEN e:expr CLOSE {rule=e}

ctypeexpr  <- CTYPE CIDENT STAR*

cfuncexpr  <- CFUNC CIDENT

preretexpr <- r:RET e:expr {rule=node(RET, r, e)}


/********************/
/* TOKEN NODE KINDS */
/********************/

%node PROG
%node SHEBANG
%node NAMESPACE

%node TEMPLATE
%node MEMBERLIST
%node STRUCT
%node TMPLSTRUCT
%node UNION
%node TMPLUNION
%node TRAIT
%node TMPLTRAIT


%node QUEST
%node COLON

%node FOR
%node WHILE

%node CAST
%node REF
%node DEREF
%node BLK
%node LAMBDA

%node EQ
%node PLEQ
%node MINEQ
%node MULEQ
%node DIVEQ
%node MODEQ
%node ANDEQ
%node OREQ
%node XOREQ
%node BNEQ
%node BSREQ
%node BSLEQ

%node LOGOR
%node LOGAND
%node OR
%node XOR
%node AND

%node DEQ
%node NEQ

%node LT
%node GT
%node LEQ
%node GEQ

%node BSL
%node BSR

%node STAR
%node MUL
%node DIV
%node MOD
%node POW

%node SUM
%node PLUS
%node MINUS

%node RET
%node GRAVE

%node SELF
%node SELFTYPE
%node VOIDTYPE
%node FNTYPE

%node OPEN
%node CLOSE
%node NUMLIT
%node STRLIT
%node TYPEMEMBER
%node STRUCTIDENT
%node TRAITIDENT
%node VARIDENT




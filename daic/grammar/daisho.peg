%include <assert.h>
%extra     void* symtab;
%extra     void* type;
%extrainit node->symtab = NULL;
%extrainit node->type = NULL;
%postinclude "../asthelpers.h"

file      <- sh:SHEBANG? (expr / decl) (SEMI (expr / decl))*

/****************/
/* DECLARATIONS */
/****************/

decl       <- nsdecl / structdecl / uniondecl / traitdecl / impldecl / ctypedecl / aliasdecl / fndecl


nsdecl     <- NAMESPACE t:TYPEIDENT {rule=node(NAMESPACEDECL, t)}

structdecl <- STRUCT id:TYPEIDENT tmpl:tmpldecl?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:typemember {add(members, m)})*
              RCBRACK
              n:{n = node(STRUCTDECL, id, members);
              rule = has(tmpl) ? node(TMPLSTRUCT, tmpl, n) : n}

uniondecl  <- UNION id:TYPEIDENT tmpl:tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:typemember {add(members, m)})*
              RCBRACK
              n:{n = node(UNIONDECL, id, members);
              rule = has(tmpl) ? node(TMPLUNION, tmpl, n) : n}

traitdecl  <- TRAIT id:TYPEIDENT tmpl:tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:fnmember {add(members, m)})*
              RCBRACK
              n:{n = node(TRAITDECL, id, members);
              rule = has(tmpl) ? node(TMPLTRAIT, tmpl, n) : n}

impldecl   <- IMPL tt:TYPEIDENT tmplexpand?
              FOR ft:type
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:fnmember {add(members, m)})*
              RCBRACK

typemember <- t:type v:VARIDENT SEMI {rule=node(TYPEMEMBER, t, v)}

fnmember   <- r:(fndecl / cfndecl / fnproto) SEMI {rule=r}

%node CIDENT
ctypedecl  <- CTYPE t:TYPEIDENT c:CIDENT {rule=srepr(node(CTYPEDECL, t, c), "ctypedecl")}

aliasdecl  <- ALIAS t:TYPEIDENT f:type {rule=srepr(node(ALIASDECL, t, f), "aliasdecl")}

fndecl     <- FN rt:type t:VARIDENT t:tmplexpand? OPEN CLOSE e:expr {rule=srepr(node(FNDECL, rt, t, e), "fndecl")}

%node CFNDECL
cfndecl    <- CFN rt:type t:VARIDENT t:tmplexpand? OPEN CLOSE e:expr {rule=srepr(node(CFNDECL, rt, t, e), "cfndecl")}




/*************/
/* TEMPLATES */
/*************/

%node TMPLDECL
tmpldecl    <- LT l:{rule=ret=list(TMPLDECL)}
               m:tmpldeclmember? {if (has(m)) add(l, m)} (COMMA m:tmpldeclmember {add(l, m)})* COMMA?
               GT

tmpldeclmember <- type TYPEIDENT (EQ type)?

tmplexpand <- LT l:{rule=ret=list(TMPLEXPANDLIST)}
              m:tmplex? {if (has(m)) add(l, m)} (COMMA m:tmplex {add(l, m)})* COMMA?
              GT

tmplex <- type / NUMLIT


/********************/
/* TYPE ANNOTATIONS */
/********************/

// a type, not a type definition
type<uint8_t depth = 0>
           <- v:VOIDTYPE    !STAR              {rule=set_depth(v, 0)}     // Void means nothing.
            / p:voidptr     (STAR {depth++})*  {rule=set_depth(p, depth)} // Void* means anything.
            / s:SELFTYPE    (STAR {depth++})*  {rule=set_depth(s, depth)} // Self refers to the type of the first arg, or the current type.
            / f:fntype      (STAR {depth++})*  {rule=set_depth(f, depth)} // Fn<From -> To> is To(*fptr)(From).
            / t:ttexpand    (STAR {depth++})*  {rule=set_depth(t, depth)} // Type or Trait object, possibly templated

voidptr    <- v:VOIDPTR         {rule=v}
            / v:VOIDTYPE s:STAR {rule=srepr(leaf(VOIDPTR), "VoidPtr")}

ttexpand <- i:(TYPEIDENT / TRAITIDENT) t:tmplexpand?
              {rule = has(t) ? node(TMPLTYPE, t, i) : i}

fntype     <- FNTYPE
              LT
              argtypes:{ret=list(ARGLIST)}
              (      t:type {add(argtypes, t)})?
              (COMMA t:type {add(argtypes, t)})*
              {if (!argtypes->num_children) add(argtypes, leaf(VOIDTYPE))}
              ((ARROW / SEMI / EQ GT) rettype:type)?
              GT
              {rule=node(FNTYPE, argtypes, !has(rettype) ? leaf(VOIDTYPE) : rettype)}
              /
              FNTYPE
              l:{l=list(ARGLIST);add(l, leaf(VOIDTYPE))}
              {rule=node(FNTYPE, l, leaf(VOIDTYPE))}


/***********************/
/* FUNCTIONS AND TYPES */
/***********************/


fnproto    <- type OPEN fnarg? (COMMA fnarg)* CLOSE

fnarg      <- type (VARIDENT tmplexpand?)?

fnbody     <- expr


/****************************/
/* CONTROL FLOW EXPRESSIONS */
/****************************/

expr       <- next

%node IF
%node IFELSE
ifeexpr    <- IF cond:ternexpr ex:expr (ELSE eex:expr)?
              {rule= !has(eex) ? srepr(node(IF, cond, ex), "if") : srepr(node(IFELSE, cond, ex, eex), "if-else")}
            / n:next {rule=n}

forexpr    <- FOR OPEN? n:next ((COLON / IN) / (SEMI sn:next SEMI))  n:next CLOSE? n:next
            / n:next {rule=n}

whileexpr  <- WHILE o:OPEN? n:next c:CLOSE? {ret=o==c?SUCC:NULL} expr
            / n:next {rule=n}

ternexpr   <- n:next (q:QUEST qe:expr (c:COLON ce:expr)?)?
              {rule = !has(qe) ? n
                    : !has(ce) ? node(ELVIS, q, n, qe)
                    :            node(TERN, q, c, n, qe, ce)}

thenexpr   <- n:next {rule=n} (o:THEN nn:next {rule=srepr(node(THEN, rule, nn), "then")})*

alsoexpr   <- n:next {rule=n} (o:ALSO nn:next {rule=srepr(node(ALSO, rule, nn), "also")})*


/********************/
/* BINARY OPERATORS */
/********************/

binop      <- next

eqexpr     <- n:next {rule=n}
             (op:(EQ / PLEQ / MINEQ / MULEQ / DIVEQ / MODEQ / ANDEQ / OREQ / XOREQ / BNEQ / BSREQ / BSLEQ)
              t:next
              // Requires information about what the next expression is
              {
                if      (op->kind == kind(EQ))    rule=node(EQ, rule,                   t );
                else if (op->kind == kind(PLEQ))  rule=node(EQ, rule, node(PLUS,  rule, t));
                else if (op->kind == kind(MINEQ)) rule=node(EQ, rule, node(MINUS, rule, t));
                else if (op->kind == kind(MULEQ)) rule=node(EQ, rule, node(MUL,   rule, t));
                else if (op->kind == kind(DIVEQ)) rule=node(EQ, rule, node(DIV,   rule, t));
                else if (op->kind == kind(MODEQ)) rule=node(EQ, rule, node(MOD,   rule, t));
                else if (op->kind == kind(ANDEQ)) rule=node(EQ, rule, node(AND,   rule, t));
                else if (op->kind == kind(OREQ))  rule=node(EQ, rule, node(OR,    rule, t));
                else if (op->kind == kind(XOREQ)) rule=node(EQ, rule, node(BNEQ,  rule, t));
                else if (op->kind == kind(BSREQ)) rule=node(EQ, rule, node(BSR,   rule, t));
                else if (op->kind == kind(BSLEQ)) rule=node(EQ, rule, node(BSL,   rule, t));
                else
                  #if defined(__DAI_UNREACHABLE)
                    __DAI_UNREACHABLE()
                  #else
                    assert(!"Unexpected node type.")
                  #endif
              })*

logorexpr  <- n:next {rule=n} (LOGOR  n:next {rule=srepr(node(LOGOR,  rule, n), "||")})*
logandexpr <- n:next {rule=n} (LOGAND n:next {rule=srepr(node(LOGAND, rule, n), "&&")})*
binorexpr  <- n:next {rule=n} (OR     n:next {rule=srepr(node(OR,     rule, n), "|")})*
binxorexpr <- n:next {rule=n} (XOR    n:next {rule=srepr(node(XOR,    rule, n), "^")})*
binandexpr <- n:next {rule=n} (AND    n:next {rule=srepr(node(AND,    rule, n), "&")})*

deneqexpr  <- n:next {rule=n}
             (DEQ n:next {rule=srepr(node(DEQ, rule, n), "==")}
             /NEQ n:next {rule=srepr(node(NEQ, rule, n), "!=")})*

cmpexpr    <- n:next {rule=n}
             (LT  n:next {rule=srepr(node(LT,  rule, n), "<")}
             /GT  n:next {rule=srepr(node(GT,  rule, n), ">")}
             /LEQ n:next {rule=srepr(node(LEQ, rule, n), "<=")}
             /GEQ n:next {rule=srepr(node(GEQ, rule, n), ">=")})*

sumexpr    <- n:next {rule=n}
             (PLUS  n:next {rule=srepr(node(PLUS,  rule, n), "+")}
             /MINUS n:next {rule=srepr(node(MINUS, rule, n), "-")})*

multexpr   <- n:next {rule=n}
             (STAR n:next {rule=srepr(node(STAR, rule, n), "*")}
             /DIV  n:next {rule=srepr(node(DIV,  rule, n), "/")}
             /MOD  n:next {rule=srepr(node(MOD,  rule, n), "%")})*

powexpr    <- n:next {rule=n}
             (POW {rule=srepr(node(POW, rule, n), "**")})*


shfexpr    <- n:next {rule=n} // Tokenized as << and >>.
             (LT LT n:next {rule=srepr(node(BSL, rule, n), "<<")}
             /GT GT n:next {rule=srepr(node(BSR, rule, n), ">>")})*

callexpr   <- vi:VARIDENT t:tmplexpand?
              (args:fncallargs
              {rule=node(CALL, vi, args); if (has(t)) {rule=node(TMPLCALL, rule, t);t=NULL;}})*
              {ret=!has(rule)?NULL:SUCC}
              /
              n:castexpr {rule=n}
              (args:fncallargs {rule=node(CALL, rule, args)})*

fncallargs <- OPEN l:{ret=rule=list(FNARGLIST)}
              e:expr? {if (has(e)) add(l, e)} (COMMA e:expr {add(l, e)})* COMMA?
              CLOSE

castexpr   <- n:next {rule=n} (OPEN t:type CLOSE {rule = srepr(node(CAST, rule, t), "cast")})* 

refexpr    <- n:next r:REF?    {rule=has(r) ? srepr(node(REF, n), "@") : n}

derefexpr  <- n:next d:DEREF?  {rule=has(d) ? srepr(node(REF, n), "$") : n}

postretexpr <- n:next g:GRAVE? {rule=has(g) ? srepr(node(RET, n), "return") : n}


/*********************************/
/* ATOMS AND SPECIAL EXPRESSIONS */
/*********************************/

atomexpr   <- blockexpr
            / lambdaexpr
            / listcomp
            / listlit
            / parenexpr
            / preretexpr
            / VARIDENT
            / numlit
            / strlit

blockexpr  <- LCBRACK
              {rule=list(BLK)}
              (e:expr {add(rule, e)})*
              RCBRACK

%node CAPLIST
// Captures, Arguments, Expression
lambdaexpr <- (LSBRACK v:VARIDENT? caps:{ret=list(ARGLIST);if (has(v)) add(ret, v)}
              (COMMA v:VARIDENT {add(caps, v)})* RSBRACK)?
              args:{ret=list(ARGLIST)}
              (({ret=(!caps || !caps->num_children)?SUCC:NULL} v:VARIDENT {add(args, v)}) /
              (OPEN v:VARIDENT? {add(args, v)} (COMMA v:VARIDENT {add(args, v)})* CLOSE))
              ARROW e:expr {rule=node(LAMBDA, caps, args, e)}

listcomp   <- LSBRACK
              (cnt:VARIDENT COMMA)? expr   // Optional count
              FOR item:VARIDENT
              IN in:expr
              (WHERE where:expr)?
              RSBRACK

listlit    <- LSBRACK expr? (COMMA expr)* COMMA? RSBRACK

parenexpr  <- OPEN e:expr CLOSE {rule=e}

preretexpr <- r:RET e:expr {rule=node(RET, r, e)}

numlit     <- pm:(PLUS / MINUS)? nl:NUMLIT {rule = nl}

strlit     <- STRLIT / FSTRLIT


/**************/
/* NODE KINDS */
/**************/

%node PROG
%node SHEBANG
%node NAMESPACE
%node GLOBALSCOPE

%node NAMESPACEDECL
%node STRUCTDECL
%node UNIONDECL
%node TRAITDECL
%node CTYPEDECL
%node ALIASDECL
%node FNDECL

%node TMPLBEGIN
%node TMPLEXPAND
%node TMPLEXPANDLIST

%node TMPLSTRUCT
%node TMPLUNION
%node TMPLTRAIT
%node TMPLTYPE

%node MEMBERLIST
%node STRUCT
%node UNION
%node TRAIT
%node TRAITTYPE
%node STRUCTTYPE
%node VOIDPTR

%node QUEST
%node COLON

%node FOR
%node WHILE

%node CAST
%node REF
%node DEREF
%node BLK
%node ARGLIST
%node ARROW
%node LAMBDA

%node EQ
%node PLEQ
%node MINEQ
%node MULEQ
%node DIVEQ
%node MODEQ
%node ANDEQ
%node OREQ
%node XOREQ
%node BNEQ
%node BSREQ
%node BSLEQ

%node TERN
%node ELVIS
%node THEN
%node ALSO

%node LOGOR
%node LOGAND
%node OR
%node XOR
%node AND

%node DEQ
%node NEQ

%node LT
%node GT
%node LEQ
%node GEQ

%node BSL
%node BSR

%node STAR
%node MUL
%node DIV
%node MOD
%node POW

%node SUM
%node PLUS
%node MINUS

%node RET
%node GRAVE

%node CALL
%node TMPLCALL
%node FNARGLIST

%node SELF
%node SELFTYPE
%node VOIDTYPE
%node FNTYPE

%node OPEN
%node CLOSE
%node NUMLIT
%node STRLIT
%node FSTRLIT
%node TYPEMEMBER
%node TYPEIDENT
%node TRAITIDENT
%node VARIDENT

file       <- sh:SHEBANG? topdecl (SEMI topdecl)*

/****************/
/* DECLARATIONS */
/****************/

topdecl    <- nsdecl / decl

decl       <- structdecl / uniondecl / traitdecl / impldecl / nsdecl

structdecl <- STRUCT id:STRUCTIDENT tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
             (typemember)*
              RCBRACK

uniondecl  <- UNION id:STRUCTIDENT tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
             (typemember)*
              RCBRACK

traitdecl  <- TRAIT id:STRUCTIDENT tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
             (fnmember)*
              RCBRACK

fndecl     <- FN fnproto tmplexpand? fnbody

impldecl   <- IMPL tt:STRUCTIDENT tmplexpand?
              FOR ft:type
              LCBRACK
             (fnmember)*
              RCBRACK

nsdecl     <- NAMESPACE t:STRUCTIDENT {rule=node(NAMESPACE, t)}

typemember <- t:type v:VARIDENT SEMI {rule=node(TYPEMEMBER, t, v)}

fnmember   <- r:(fndecl / fnproto) SEMI {rule=r}


/*********/
/* TYPES */
/*********/

type       <- VOIDTYPE  !STAR    // Void means nothing.
            / VOIDTYPE   STAR+   // Void* means anything.
            / traittype  STAR*   // Trait object (+1 pointer, trait)
            / structtype STAR*   // Type identifier
            / fntype     STAR*
            
traittype  <- TRAITIDENT tmplexpand?

structtype <- STRUCTIDENT tmplexpand?

fntype     <- fn:FNTYPE LT
              argtypelist:(type? (COMMA type)*)
              ARROW
              rettype:type
              GT


/***********************/
/* FUNCTIONS AND TYPES */
/***********************/

tmpldecl   <- TEMPLATE

tmplexpand <- LT GT

fnproto    <- type OPEN fnarg? (COMMA fnarg)* CLOSE

fnarg      <- type (VARIDENT tmplexpand?)?

fnbody     <- expr


/****************************/
/* CONTROL FLOW EXPRESSIONS */
/****************************/

expr       <- next

cfexpr     <- forexpr / whileexpr / ifexpr

forexpr    <- FOR OPEN? expr (COLON / IN)   expr CLOSE? expr
            / FOR OPEN? expr SEMI expr SEMI expr CLOSE? expr

whileexpr  <- WHILE OPEN? expr CLOSE? expr

ifexpr     <- next QUEST expr (COLON expr)?


/********************/
/* BINARY OPERATORS */
/********************/

binop      <- 

eqexpr     <- n:next {rule=n}
             (op:(EQ / PLEQ / MINEQ / MULEQ / DIVEQ / MODEQ / ANDEQ / OREQ / XOREQ / BNEQ / BSREQ / BSLEQ)
              n:next {rule=node(EQ, op, rule, n)})*

logorexpr  <- n:next {rule=n} (op:LOGOR  n:next {rule=node(LOGOR,  op, rule, n)})*
logandexpr <- n:next {rule=n} (op:LOGAND n:next {rule=node(LOGAND, op, rule, n)})*
binorexpr  <- n:next {rule=n} (op:OR     n:next {rule=node(OR,     op, rule, n)})*
binxorexpr <- n:next {rule=n} (op:XOR    n:next {rule=node(XOR,    op, rule, n)})*
binandexpr <- n:next {rule=n} (op:AND    n:next {rule=node(AND,    op, rule, n)})*

deneqexpr  <- n:next {rule=n}
             (op:(DEQ / NEQ)
              n:next {rule=node(EQCHECK, op, rule, n)})*

cmpexpr    <- n:next {rule=n}
             (op:(LT / GT / LEQ / GEQ)
              n:next {rule=node(CMP, op, rule, n)})*

shfexpr    <- n:next {rule=n}
             (op:(lshf / rshf) // Tokenized as << and >>. See the rule.
              n:next {rule=node(SHIFT, op, rule, n)})*
lshf       <- l:LT lt:LT {rule=node(LSHF, l, lt)}
rshf       <- g:GT gt:GT {rule=node(RSHF, g, gt)}

multexpr   <- n:next {rule=n}
             (op:(STAR / DIV / MOD)
              n:next {rule=node(FACTOR, op, rule, n)})*

sumexpr    <- n:next {rule=n}
             (op:(PLUS / MINUS)
              n:next {rule=node(SUM, op, rule, n)})*

/* (Cast) (Call) */
castexpr   <- n:next o:OPEN t:type CLOSE {rule=node(CAST, o, t, n)}
            / re:refexpr { rule = re; }

callexpr   <- n:next t:tmplexpand? OPEN CLOSE

/* @ $ */
refexpr    <- n:next a:REF? {rule=(a != SUCC) ? node(REF, a, n) : n}
derefexpr  <-

postretexpr <- n:next g:GRAVE? {rule=(g != SUCC)?node(RET, g, n) : n}

/*********************************/
/* ATOMS AND SPECIAL EXPRESSIONS */
/*********************************/

atomexpr   <- VARIDENT
            / NUMLIT
            / STRLIT
            / blockexpr
            / lambdaexpr
            / listcomp
            / listlit
            / parenexpr
            / ctypeexpr
            / cfuncexpr
            / preretexpr

blockexpr  <- LCBRACK
              {rule=list(BLK)}
              (e:expr {add(rule, e)})*
              RCBRACK

lambdaexpr <- OPEN CLOSE

listcomp   <- LSBRACK
              (cnt:VARIDENT COMMA)? expr   // Optional count
              FOR item:VARIDENT
              IN expr
              (WHERE expr)?
              RSBRACK

listlit    <- LSBRACK expr? (COMMA expr)* COMMA? RSBRACK

parenexpr  <- OPEN expr CLOSE

ctypeexpr  <- CTYPE CIDENT STAR*

cfuncexpr  <- CFUNC CIDENT

preretexpr <- RET e:expr {rule=node(RET, e)}


/********************/
/* TOKEN NODE KINDS */
/********************/

%node PROG
%node SHEBANG
%node NAMESPACE

%node QUEST
%node COLON

%node FOR
%node WHILE

%node CAST
%node REF
%node DEREF
%node BLK
%node LAMBDA

%node EQ
%node PLEQ
%node MINEQ
%node MULEQ
%node DIVEQ
%node MODEQ
%node ANDEQ
%node OREQ
%node XOREQ
%node BNEQ
%node BSREQ
%node BSLEQ

%node LOGOR
%node LOGAND
%node OR
%node XOR
%node AND

%node EQCHECK
%node DEQ
%node NEQ

%node CMP
%node LT
%node GT
%node LEQ
%node GEQ

%node SHIFT
%node LSHF
%node RSHF

%node FACTOR
%node STAR
%node DIV
%node MOD

%node SUM
%node PLUS
%node MINUS

%node RET
%node GRAVE

%node VOIDTYPE
%node FNTYPE

%node OPEN
%node CLOSE
%node VIDENT
%node NUMLIT
%node STRLIT
%node TYPEMEMBER
%node STRUCTIDENT
%node VARIDENT

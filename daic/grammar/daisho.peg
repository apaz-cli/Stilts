%precode #ifndef DAIC_TYPES_INCLUDE
%precode #include "../types.h"
%precode #endif
%code #ifndef DAIC_ASTHELPERS_INCLUDE
%code #include "../asthelpers.h"
%code #endif
%include     <daisho/Daisho.h>

%precode     struct Symtab;
%precode     struct ExprType;
%extra       Symtab* symtab; // Anything in the scope created by this expression
%extra       ExprType* type; // The concrete type of this expression
%extrainit   node->symtab = NULL;
%extrainit   node->type = NULL;


program      <- sh:SHEBANG? nses:{list(NSLIST)}
               (f:namespace {add(nses, f)})+ {rule=node(PROGRAM, sh, nses)}

namespace    <- ns:NAMESPACE name:TYPEIDENT wsemi l:{list(NSDECLS)}
                t:topdecl {add(l, t)} (wsemi t:topdecl {add(l, t)})*
                {rule=node(NAMESPACE, name, l)}

/****************/
/* DECLARATIONS */
/****************/

topdecl    <- structdecl / uniondecl / traitdecl / fndecl / impldecl / ctypedecl

structdecl <- STRUCT id:TYPEIDENT tmpl:tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:typemember {add(members, m)})*
              RCBRACK
              n:{n = node(STRUCT, id, members);
              rule = has(tmpl) ? node(TMPLSTRUCT, tmpl, n) : n}

uniondecl  <- UNION id:TYPEIDENT tmpl:tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:typemember {add(members, m)})*
              RCBRACK
              n:{n = node(UNION, id, members);
              rule = has(tmpl) ? node(TMPLUNION, tmpl, n) : n}

traitdecl  <- TRAIT id:TYPEIDENT tmpl:tmplexpand?
              impl:(IMPL type (COMMA type)*)?
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:fnmember {add(members, m)})*
              RCBRACK
              n:{n = node(TRAIT, id, members);
              rule = has(tmpl) ? node(TMPLTRAIT, tmpl, n) : n}

fndecl     <- FN rett:type name:VARIDENT e:tmplexpand? OPEN arglist CLOSE expr

fnproto    <- FN rett:type name:VARIDENT e:tmplexpand? OPEN protolist CLOSE wsemi

impldecl   <- IMPL tt:TYPEIDENT tmplexpand?
              FOR ft:type
              LCBRACK
              members:{ret=list(MEMBERLIST)}
             (m:fnmember {add(members, m)})*
              RCBRACK

typemember <- t:type v:VARIDENT
              {rule=node(TYPEMEMBER, t, v)}

fnmember   <- rule:fndecl
            / rule:fnproto wsemi

tmplexpand <- LT rule:typelist {rule->kind=kind(TMPLEXPAND)} GT


/*********/
/* TYPES */
/*********/

type       <- fntype

fntype     <- from:{} to:ptrtype
              (ARROW n:ptrtype
              {if (!has(from)) from = list(TYPELIST)}
              {add(from, to); to = n})*
              {rule=has(from) ? node(FNTYPE, from, to) : to}

ptrtype    <- rule:basetype (STAR {rule=node(PTRTYPE, rule)})*

basetype   <- OPEN rule:type CLOSE
            / SELFTYPE
            / v:VOIDTYPE !STAR {rule=v}
            / voidptr
            / ctypedecl
            / s:TYPEIDENT t:tmplexpand? {rule=has(t) ? node(TMPLTYPE, t, s) : s}

%node TUPLETYPE
tupletype  <- OPEN t:type COMMA CLOSE {rule=node(TUPLETYPE, t)}
            / OPEN rule:typelist CLOSE {rule->kind = kind(TUPLETYPE)}

voidptr    <- v:VOIDPTR         {rule=v}
            / v:VOIDTYPE s:STAR {rule=leaf(VOIDPTR)}

ctypedecl  <- CTYPE i:TYPEIDENT c:CIDENT
              {rule=node(CTYPEDECL, i, c)}


/***********************/
/* FUNCTIONS AND TYPES */
/***********************/

typelist   <- nocomma? {rule=list(TYPELIST)}
              t:type? {if has(t) add(rule, t)}
             (COMMA t:type {add(rule, t)})* nocomma?

exprlist   <- nocomma? {rule=list(EXPRLIST)}
              e:expr? {if has(e) add(rule, e)}
             (COMMA e:expr {add(rule, e)})* nocomma?

fnarg      <- t:type i:VARIDENT
              {rule=node(FNARG, t, i)}
arglist    <- nocomma? {rule=list(ARGLIST)}
              a:fnarg {if has(a) add(rule, a)}
             (COMMA a:fnarg {add(rule, a)})* nocomma?

protoarg   <- t:type i:VARIDENT?
              {rule=has(i) ? node(PROTOARG, t, i) : node(PROTOARG, t)}
protolist  <- nocomma? {rule=list(PROTOLIST)}
              p:protoarg {if has(p) add(rule, p)}
             (COMMA p:protoarg {add(rule, p)})* nocomma?


/***************/
/* EXPRESSIONS */
/***************/

expr       <- next

preretexpr <- RET n:expr {rule=node(RET, n)}
            / rule:next (GRAVE {rule = node(RET, rule)})?

forexpr    <- FOR o:OPEN?
              f:expr ((COLON / IN) / (wsemi s:expr wsemi)) t:expr
              c:CLOSE? {if (has(o) != has(c)) WARNING("For expression parens mismatch.")}
              e:expr
              {rule = has(s) ? node(FOR, f, s, t, e)
                    :          node(FOREACH, f, t, e)}
            / rule:next

whileexpr  <- WHILE o:OPEN? n:expr c:CLOSE?
              {if (has(o) != has(c)) FATAL("While expression parens mismatch.")}
              e:expr {rule=node(WHILE, n, e)}
            / rule:next

preifexpr  <- IF o:OPEN? n:expr c:CLOSE?
              {if (has(o) != has(c)) FATAL("If expression parens mismatch.")}
              e:expr
              (ELSE ee:expr)?
              {rule = !has(ee) ? node(IF, n, e)
                    :            node(TERN, n, e, ee)}
            / rule:next

ternexpr   <- n:next (QUEST qe:expr (COLON ce:expr)?)?
              {rule = !has(qe) ? n
                    : !has(ce) ? node(IF, n, qe)
                    :            node(TERN, n, qe, ce)}

thenexpr   <- rule:next (THEN nn:next {rule=node(THEN, rule, nn)})*

alsoexpr   <- rule:next (ALSO nn:next {rule=node(ALSO, rule, nn)})*

ceqexpr    <- rule:next
             (op:(EQ / PLEQ / MINEQ / MULEQ / DIVEQ / MODEQ / ANDEQ / OREQ / XOREQ / BNEQ / BSREQ / BSLEQ)
              t:next
              // Requires information about what the next expression is
              {
                if      (op->kind == kind(EQ))    rule=node(EQ, rule,                   t );
                else if (op->kind == kind(PLEQ))  rule=node(EQ, rule, node(PLUS,  rule, t));
                else if (op->kind == kind(MINEQ)) rule=node(EQ, rule, node(MINUS, rule, t));
                else if (op->kind == kind(MULEQ)) rule=node(EQ, rule, node(MUL,   rule, t));
                else if (op->kind == kind(DIVEQ)) rule=node(EQ, rule, node(DIV,   rule, t));
                else if (op->kind == kind(MODEQ)) rule=node(EQ, rule, node(MOD,   rule, t));
                else if (op->kind == kind(ANDEQ)) rule=node(EQ, rule, node(AND,   rule, t));
                else if (op->kind == kind(OREQ))  rule=node(EQ, rule, node(OR,    rule, t));
                else if (op->kind == kind(XOREQ)) rule=node(EQ, rule, node(BNEQ,  rule, t));
                else if (op->kind == kind(BSREQ)) rule=node(EQ, rule, node(BSR,   rule, t));
                else if (op->kind == kind(BSLEQ)) rule=node(EQ, rule, node(BSL,   rule, t));
                else _DAI_UNREACHABLE()
              })*

logorexpr  <- rule:next (LOGOR  n:next {rule=node(LOGOR,  rule, n)})*
logandexpr <- rule:next (LOGAND n:next {rule=node(LOGAND, rule, n)})*
binorexpr  <- rule:next (OR     n:next {rule=node(OR,     rule, n)})*
binxorexpr <- rule:next (XOR    n:next {rule=node(XOR,    rule, n)})*
binandexpr <- rule:next (AND    n:next {rule=node(AND,    rule, n)})*

deneqexpr  <- rule:next
             (DEQ n:next {rule=node(DEQ, rule, n)}
             /NEQ n:next {rule=node(NEQ, rule, n)})*

cmpexpr    <- rule:next
             (LT  n:next {rule=node(LT,  rule, n)}
             /GT  n:next {rule=node(GT,  rule, n)}
             /LEQ n:next {rule=node(LEQ, rule, n)}
             /GEQ n:next {rule=node(GEQ, rule, n)})*

shfexpr    <- rule:next // Tokenized as < < and > >.
             (l:LT lt:LT n:next {rule=node(BSL, l, lt, rule, n)}
             /g:GT gt:GT n:next {rule=node(BSR, g, gt, rule, n)})*

sumexpr    <- rule:next
             (p:PLUS  n:next {rule=node(PLUS, rule, n)}
             /m:MINUS n:next {rule=node(MINUS, rule, n)})*

multexpr   <- rule:next
             (STAR n:next {rule=node(STAR, rule, n)}
             /DIV  n:next {rule=node(DIV,  rule, n)}
             /MOD  n:next {rule=node(MOD,  rule, n)}
             /POW  n:next {rule=node(POW,  rule, n)})*

accexpr    <- rule:next (LSBRACK e:expr RSBRACK {rule=node(ACCESS, rule, e)})*

dotexpr    <- rule:next (DOT i:VARIDENT {rule=node(DOT, rule, i)})*

refexpr<int32_t rd = 0>
           <- rule:next (REF {rd++} / DEREF {rd--})*
             {for (int64_t i = 0; i < (rd > 0 ? rd : -rd); i++) {
                rule = rd > 0 ? node(REF, rule) : node(DEREF, rule);
              }}

callexpr   <- rule:next
              ({ret=rule->kind == kind(VARIDENT) ? SUCC : NULL} te:tmplexpand)?
              (OPEN el:exprlist CLOSE
              {rule = !has(te) ? node(CALL, rule, el)
                    :            node(CALL, rule, te, el)})*

castexpr   <- rule:next (OPEN t:type CLOSE {rule=node(CAST, rule, t)})*

increxpr   <- rule:next ((INCR {rule=node(INCR, rule)})
                        /(DECR {rule=node(DECR, rule)}))?

/*********************************/
/* ATOMS AND SPECIAL EXPRESSIONS */
/*********************************/

atomexpr   <-
            // {}
                blockexpr
            // VAR
              / VARIDENT
            // Type
              / vardeclexpr
            // ()
              / lambdaexpr
              / parenexpr
              / tuplelit
            // []
              / listcomp
              / listlit
            // Unambiguous
              / strlit
              / NUMLIT
              / cfuncexpr
              / SELFVAR
              / sizeofexpr

blockexpr  <- LCBRACK {rule=list(BLOCK)}
              (!RCBRACK e:expr SEMI {add(rule, e)})*
              RCBRACK

lambdaexpr <- args:{}
              ((VARIDENT)
              /(OPEN arglist CLOSE))
              ARROW
              expr

listcomp   <- LSBRACK
             (cnt:VARIDENT COMMA)? expr
              FOR item:VARIDENT
              IN expr
             (WHERE expr)?
              RSBRACK

parenexpr  <- OPEN rule:expr CLOSE

listlit    <- LSBRACK
              rule:exprlist {rule->kind = kind(LISTLIT)}
              RSBRACK

tuplelit   <- OPEN
              rule:exprlist {rule->kind = kind(TUPLELIT)}
              CLOSE

%node MAPLIT
//mapexpr    <- LCBRACK e:expr DARROW v:value
//             (COMMA RCBRACK / (COMMA e:expr DARROW v:value)* COMMA? RCBRACK)

cfuncexpr  <- CFN CIDENT

%node VARDECL
vardeclexpr <- t:type i:VARIDENT {rule=node(VARDECL, t, i)}

strlit     <- sstrlit
            / fstrlit

sstrlit    <- s:STRLIT {rule=list(SSTR); add(rule, s)}
             (s:STRLIT {add(rule, s)})*

fstrlit    <- f:fstrfrag {rule=list(FSTR); add(rule, f)}
             (f:fstrfrag {add(rule, f)})*

fstrfrag   <- STRLIT
            / s:FSTRLITSTART {rule=list(FSTRFRAG); add(rule, s)}
              x:expr {add(rule, x)}
             (m:FSTRLITMID x:expr {add(rule, m); add(rule, x)})*
              e:FSTRLITEND {add(rule, e)}

sizeofexpr <- SIZEOF OPEN te:(type / expr) CLOSE {rule=node(SIZEOF, te)}

/******************/
/* ERROR HANDLING */
/******************/

%node RECOVERY
wexpr      <- (expr  / {WARNING("Missing expression."); ret=leaf(RECOVERY)})
noexpr     <- (e:expr  {WARNING("Extra expression."); ret=e})
wcomma     <- (COMMA / {WARNING("Missing comma."); ret=leaf(COMMA)})
nocomma    <- (c:COMMA {WARNING("Extra comma."); ret=c})
wsemi      <- (SEMI  / {WARNING("Missing semicolon."); ret=leaf(SEMI)})
nosemi     <- (s:SEMI  {WARNING("Extra semicolon."); ret=s})



/**************/
/* NODE KINDS */
/**************/

%node PROGRAM
%node NSLIST
%node NSDECLS

%node MEMBERLIST
%node TMPLSTRUCT
%node TMPLUNION
%node TMPLTRAIT
%node TMPLTYPE
%node TRAITTYPE
%node STRUCTTYPE
%node CTYPEDECL
%node TMPLEXPAND

%node TERN
%node MUL
%node BSR
%node BSL

%node BLOCK
%node CAST
%node LAMBDA
%node FOREACH
%node CALL
%node ACCESS
%node LISTLIT
%node TUPLELIT

%node FNARG
%node PROTOARG
%node EXPANDLIST
%node ARGLIST
%node TYPELIST
%node EXPRLIST
%node PROTOLIST

%node TYPE
%node PTRTYPE
%node TYPEMEMBER
%node DTRAITIDENT

%node SSTR
%node FSTR
%node FSTRFRAG


///////////////
// Operators //
///////////////

// Note: << and >> are handled in the parser.
// This is helpful for parsing templates.
PLUS:   "+";
MINUS:  "-";
STAR:    "*";
POW:     "**";
DIV:     "/";
MOD:     "%";
AND:     "&";
OR:      "|";
XOR:     "^";
NOT:     "!";
BITNOT:  "~";
LOGAND:  "&&";
LOGOR:   "||";

DEQ:    "==";
NEQ:    "!=";
LT:     "<";
LEQ:    "<=";
GT:     ">";
GEQ:    ">=";

EQ:     "=";
PLEQ:   "+=";
MINEQ:  "-=";
MULEQ:  "*=";
DIVEQ:  "/=";
MODEQ:  "%=";
ANDEQ:  "&=";
OREQ:   "|=";
XOREQ:  "^=";
BNEQ:   "~=";
BSREQ:  ">>=";
BSLEQ:  "<<=";

INCR:   "++";
DECR:   "--";
QUEST:  "?";
COLON:  ":";
NCOLL:  "?:";


//////////////////
// Control Flow //
//////////////////
IF:   "if";
ELSE: "else";
//DO:   "do";
FOR:    "for";
IN:     "in";
WHILE:  "while";
THEN:   "then";
ALSO:   "also";
WHERE:  "where";

/////////
// OOP //
/////////

STRUCT: (5, 11, 16) { // class|struct|type
  (0, 'c') -> 1;
  (1, 'l') -> 2;
  (2, 'a') -> 3;
  (3, 's') -> 4;
  (4, 's') -> 5;
  (0, 's') -> 6;
  (6, 't') -> 7;
  (7, 'r') -> 8;
  (8, 'u') -> 9;
  (9, 'c') -> 10;
  (10, 't') -> 11;
  (0,  't') -> 13;
  (13, 'y') -> 14;
  (14, 'p') -> 15;
  (15, 'e') -> 16;
};
UNION: "union";
TRAIT: "trait";
IMPL:  (4, 10) { // impl([ei]ments)?
  (0, 'i') -> 1;
  (1, 'm') -> 2;
  (2, 'p') -> 3;
  (3, 'l') -> 4;
  (4, 'e') -> 5;
  (4, 'i') -> 5;
  (5, 'm') -> 6;
  (6, 'e') -> 7;
  (7, 'n') -> 8;
  (8, 't') -> 9;
  (9, 's') -> 10;
};
FN: "fn";
FNTYPE: "Fn";
CTYPE: "ctype";
CFN: "cfn";
SELFTYPE: "Self";
SELFVAR: "self";
VOIDTYPE: "Void";
VOIDPTR:  "VoidPtr";
SIZEOF: "sizeof";
NAMESPACE: (9, 15, 22) { // namespace|module|package
  (0,  'n') -> 1;(1,  'a') -> 2;(2,  'm') -> 3;(3,  'e') -> 4;(4,  's') -> 5;(5,  'p') -> 6;(6,  'a') -> 7;(7,  'c') -> 8;(8,  'e') -> 9;
  (0,  'm') -> 10;(10, 'o') -> 11;(11, 'd') -> 12;(12, 'u') -> 13;(13, 'l') -> 14;(14, 'e') -> 15;
  (0,  'p') -> 16;(16, 'a') -> 17;(17, 'c') -> 18;(18, 'k') -> 19;(19, 'a') -> 20;(20, 'g') -> 21;(21, 'e') -> 22;
};


/////////////////
// Misc Syntax //
/////////////////

SEMI:    ";";
DOT:     ".";
COMMA:   ",";
OPEN:    "(";
CLOSE:   ")";
LCBRACK: "{";
RCBRACK: "}";
LSBRACK: "[";
RSBRACK: "]";
HASH:    "#";
REF:     "@";
DEREF:   "$";
GRAVE:   "`";
ARROW:   "->";
DARROW:  "=>";


///////////////////////
// Abbreviated Words //
///////////////////////

// ret(urn)?
RET: (3, 6) {
  (0, 'r') -> 1;
  (1, 'e') -> 2;
  (2, 't') -> 3;
  (3, 'u') -> 4;
  (4, 'r') -> 5;
  (5, 'n') -> 6;
};

// op(erator)?
OP: (2, 8) {
  (0, 'o') -> 1;
  (1, 'p') -> 2;
  (2, 'e') -> 3;
  (3, 'r') -> 4;
  (4, 'a') -> 5;
  (5, 't') -> 6;
  (6, 'o') -> 7;
  (7, 'r') -> 8;
};

// redef(ine)?
REDEF: (5, 8) {
  (0, 'r') -> 1;
  (1, 'e') -> 2;
  (2, 'd') -> 3;
  (3, 'e') -> 4;
  (4, 'f') -> 5;
  (5, 'i') -> 6;
  (6, 'n') -> 7;
  (7, 'e') -> 8;
};

/////////////////////////////
// Numbers and Identifiers //
/////////////////////////////

// Starts with capital
TYPEIDENT: (1, 2) {
  (0, [A-Z]) -> 1;
  ((1, 2), [_a-zA-Zα-ωΑ-Ω0-9]) -> 2;
};

// Starts with lowercase (or noncapital)
VARIDENT: (1, 2) {
  (0, [_a-zα-ωΑ-Ω]) -> 1;
  ((1, 2), [_a-zA-Zα-ωΑ-Ω0-9]) -> 2;
};

CIDENT: (1, 2) {
  (0, [_a-z]) -> 1;
  ((1, 2), [_a-zA-Z0-9]) -> 2;
};

// [-+]?[0-9]+(\.[0-9]+)?
NUMLIT: (2, 3) {
  (0, [-+]) -> 1;
  ((0, 1, 2), [0-9]) -> 2;
  (2, '.') -> 3;
  (3, [0-9]) -> 3;
};

/////////////
// Strings //
/////////////

// ["]([^"\n\\]|\\[nfbrte\\'"{}])*["]
STRLIT: 2 {
  (0, ["])  -> 1;
  (1, ["])  -> 2;
  (1, '{')  -> -1; // fstring

  (1, [\n]) -> -1; // no newlines in string.
  (1, [\\]) -> 3;  // start parsing escape sequence
  (1, [^])  -> 1;  // string content
  (3, [n])  -> 1;  // newline
  (3, [f])  -> 1;  // form feed
  (3, [b])  -> 1;  // backspace
  (3, [r])  -> 1;  // carriage return
  (3, [t])  -> 1;  // tab
  (3, [e])  -> 1;  // escape character
  (3, [\\]) -> 1;  // backslash
  (3, ['])  -> 1;  // single quote
  (3, ["])  -> 1;  // double quote
  (3, '{')  -> 1;  // open curly
  (3, '}')  -> 1;  // close curly
};

FSTRLITSTART: 2 {
  (0, ["])  -> 1;
  (1, '{')  -> 2;
  (1, ["])  -> -1; // strlit

  (1, [\n]) -> -1; // no newlines in string.
  (1, [\\]) -> 3;  // start parsing escape sequence
  (1, [^])  -> 1;  // string content
  (3, [n])  -> 1;  // newline
  (3, [f])  -> 1;  // form feed
  (3, [b])  -> 1;  // backspace
  (3, [r])  -> 1;  // carriage return
  (3, [t])  -> 1;  // tab
  (3, [e])  -> 1;  // escape character
  (3, [\\]) -> 1;  // backslash
  (3, ['])  -> 1;  // single quote
  (3, ["])  -> 1;  // double quote
  (3, '{')  -> 1;  // open curly
  (3, '}')  -> 1;  // close curly
};

FSTRLITMID: 2 {
  (0, '}')  -> 1;
  (1, '{')  -> 2;
  (1, ["])  -> -1; // fstrend

  (1, [\n]) -> -1; // no newlines in string.
  (1, [\\]) -> 3;  // start parsing escape sequence
  (1, [^])  -> 1;  // string content
  (3, [n])  -> 1;  // newline
  (3, [f])  -> 1;  // form feed
  (3, [b])  -> 1;  // backspace
  (3, [r])  -> 1;  // carriage return
  (3, [t])  -> 1;  // tab
  (3, [e])  -> 1;  // escape character
  (3, [\\]) -> 1;  // backslash
  (3, ['])  -> 1;  // single quote
  (3, ["])  -> 1;  // double quote
  (3, '{')  -> 1;  // open curly
  (3, '}')  -> 1;  // close curly
};

FSTRLITEND: 2 {
  (0, '}')  -> 1;
  (1, ["])  -> 2;
  (1, '{')  -> -1; // fstrmid.

  (1, [\n]) -> -1; // no newlines in string.
  (1, [\\]) -> 3;  // start parsing escape sequence
  (1, [^])  -> 1;  // string content
  (3, [n])  -> 1;  // newline
  (3, [f])  -> 1;  // form feed
  (3, [b])  -> 1;  // backspace
  (3, [r])  -> 1;  // carriage return
  (3, [t])  -> 1;  // tab
  (3, [e])  -> 1;  // escape character
  (3, [\\]) -> 1;  // backslash
  (3, ['])  -> 1;  // single quote
  (3, ["])  -> 1;  // double quote
  (3, '{')  -> 1;  // open curly
  (3, '}')  -> 1;  // close curly
};


///////////////////////////////////////
// Whitespace, Comments, and Shebang //
///////////////////////////////////////

// [\ \n\r\t]+
WS: 1 {
  ((0, 1), [ \n\r\t]) -> 1;
};

// \/\*([^*]*\*)*\/
MLCOM: 4 {
  (0, '/') -> 1;
  (1, '*') -> 2;
  (2, '*') -> 3;
  (2, [^]) -> 2;
  (3, '*') -> 3;
  (3, '/') -> 4;
  (3, [^]) -> 2;
};

// \/\/[^\n]*
SLCOM: (2, 3) {
  (0, '/') -> 1;
  (1, '/') -> 2;
  (2, [^\n]) -> 2;
  (2, [\n]) -> 3;
};

// #![^\n]*[\n]
SHEBANG: 3 {
  (0, '#') -> 1;
  (1, '!') -> 2;
  (2, [^\n]) -> 2;
  (2, [\n]) -> 3;
};
